function copyObject(e,t,o){const n=["(root)"],r=[e];if("object"!=typeof e)return console.error("copyObject() 'sourceObject' argument isn't an object."),1;if("object"!=typeof t)return console.error("copyObject() 'targetObject' argument isn't an object."),1;if("number"!=typeof o&&(o<0||o>2))return console.error("copyObject() 'copyType' argument must be a number between 0 and 2 (inclusive)."),1;if(!o)for(const e in t)t.hasOwnProperty(e)&&delete t[e];return function e(t,c){let p=!0;const s=Object.getOwnPropertyNames(t);let u=s.length;for(;u--;){const l=s[u];if(1!==o||!c.hasOwnProperty(l)||t[l]===c[l]||"object"==typeof t[l]&&null!==t[l]&&"object"==typeof c[l]&&null!==c[l]||delete c[l],"object"==typeof t[l]&&null!==t[l]){if(c.hasOwnProperty(l)||(c[l]={}),c.hasOwnProperty(l)&&"object"==typeof c[l]&&null!==c[l]){const o=r.indexOf(t[l]);-1==o?(n.push(l),r.push(t[l]),p=e(t[l],c[l])&&p,n.pop(),r.pop()):(console.log(`WARNING: copyObject() circular reference detected in sourceObject; ${n.join(".")}.${l} = ${n.slice(0,o+1).join(".")}`),p=!1)}}else c.hasOwnProperty(l)||(c[l]=t[l])}return p}(e,t)?0:2}
