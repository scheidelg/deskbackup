function copyObject(e,t,o){const n=["(root)"],r=[e];if("object"!=typeof e)return console.error("copyObject() 'sourceObject' argument isn't an object."),1;if("object"!=typeof t)return console.error("copyObject() 'targetObject' argument isn't an object."),1;if("number"!=typeof o&&(o<0||o>2))return console.error("copyObject() 'copyType' argument must be a number between 0 and 2 (inclusive)."),1;if(!o)for(const e in t)t.hasOwnProperty(e)&&delete t[e];return function e(t,c){let p=!0;const s=Object.getOwnPropertyNames(t);let l=s.length;for(;l--;){const u=s[l];if(1!==o||!c.hasOwnProperty(u)||t[u]===c[u]||"object"==typeof t[u]&&null!==t[u]&&"object"==typeof c[u]&&null!==c[u]||delete c[u],"object"==typeof t[u]&&null!==t[u]){if(c.hasOwnProperty(u)||(c[u]={}),c.hasOwnProperty(u)&&"object"==typeof c[u]&&null!==c[u]){let o=r.indexOf(t[u]);-1==o?(n.push(u),r.push(t[u]),p=e(t[u],c[u])&&p,n.pop(),r.pop()):(console.log(`WARNING: copyObject() circular reference detected in sourceObject; ${n.join(".")}.${u} = ${n.slice(0,o+1).join(".")}`),p=!1)}}else c.hasOwnProperty(u)||(c[u]=t[u])}return p}(e,t)?0:2}
